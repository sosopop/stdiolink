#include "driver_proxy.h"

#include <cstring>

JSValue createOpenDriverFunction(JSContext* ctx, JSValueConst driverCtor) {
    static const char kFactorySource[] =
        "(function(DriverCtor){\n"
        "  function normalizeOptions(options) {\n"
        "    if (options == null) return { profilePolicy: 'auto', metaTimeoutMs: 5000 };\n"
        "    if (typeof options !== 'object' || Array.isArray(options)) {\n"
        "      throw new TypeError('openDriver: options must be an object');\n"
        "    }\n"
        "    const allowed = new Set(['profilePolicy', 'metaTimeoutMs']);\n"
        "    for (const k of Object.keys(options)) {\n"
        "      if (!allowed.has(k)) {\n"
        "        throw new TypeError('openDriver: unknown option: ' + k);\n"
        "      }\n"
        "    }\n"
        "    const profilePolicy = options.profilePolicy ?? 'auto';\n"
        "    if (!['auto', 'force-keepalive', 'preserve'].includes(profilePolicy)) {\n"
        "      throw new TypeError('openDriver: invalid profilePolicy: ' + profilePolicy);\n"
        "    }\n"
        "    let metaTimeoutMs = 5000;\n"
        "    if (options.metaTimeoutMs !== undefined) {\n"
        "      if (typeof options.metaTimeoutMs !== 'number') {\n"
        "        throw new TypeError('openDriver: metaTimeoutMs must be a number');\n"
        "      }\n"
        "      if (!Number.isFinite(options.metaTimeoutMs) || options.metaTimeoutMs <= 0 ||\n"
        "          !Number.isInteger(options.metaTimeoutMs)) {\n"
        "        throw new RangeError('openDriver: metaTimeoutMs must be a positive integer');\n"
        "      }\n"
        "      metaTimeoutMs = options.metaTimeoutMs;\n"
        "    }\n"
        "    return { profilePolicy, metaTimeoutMs };\n"
        "  }\n"
        "\n"
        "  function buildStartArgs(args, profilePolicy) {\n"
        "    if (args !== undefined && args !== null && !Array.isArray(args)) {\n"
        "      throw new TypeError('openDriver: args must be an array');\n"
        "    }\n"
        "    const src = Array.isArray(args) ? args : [];\n"
        "    for (const a of src) {\n"
        "      if (typeof a !== 'string') throw new TypeError('openDriver: args item must be string');\n"
        "    }\n"
        "    const out = src.slice();\n"
        "    const hasProfile = out.some(a => a.startsWith('--profile='));\n"
        "    if (profilePolicy === 'preserve') return out;\n"
        "    if (profilePolicy === 'auto') {\n"
        "      if (!hasProfile) out.push('--profile=keepalive');\n"
        "      return out;\n"
        "    }\n"
        "    const filtered = out.filter(a => !a.startsWith('--profile='));\n"
        "    filtered.push('--profile=keepalive');\n"
        "    return filtered;\n"
        "  }\n"
        "\n"
        "  return async function openDriver(program, args, options) {\n"
        "    if (typeof program !== 'string' || program.length === 0) {\n"
        "      throw new TypeError('openDriver: program must be a non-empty string');\n"
        "    }\n"
        "    const opts = normalizeOptions(options);\n"
        "    const startArgs = buildStartArgs(args, opts.profilePolicy);\n"
        "    const driver = new DriverCtor();\n"
        "    if (!driver.start(program, startArgs)) {\n"
        "      throw new Error('Failed to start driver: ' + program);\n"
        "    }\n"
        "    const meta = driver.queryMeta(opts.metaTimeoutMs);\n"
        "    if (!meta) {\n"
        "      driver.terminate();\n"
        "      throw new Error('Failed to query metadata from: ' + program +\n"
        "        ' (timeoutMs=' + opts.metaTimeoutMs + ')');\n"
        "    }\n"
        "    const commands = new Set((meta.commands || []).map(c => c.name));\n"
        "    let busy = false;\n"
        "    return new Proxy(driver, {\n"
        "      get(target, prop) {\n"
        "        if (prop === '$driver') return target;\n"
        "        if (prop === '$meta') return meta;\n"
        "        if (prop === '$rawRequest') return (cmd, data) => target.request(cmd, data || {});\n"
        "        if (prop === '$close') return () => target.terminate();\n"
        "        if (typeof prop === 'string' && commands.has(prop)) {\n"
        "          return (params = {}) => {\n"
        "            if (busy) {\n"
        "              throw new Error('DriverBusyError: request already in flight');\n"
        "            }\n"
        "            busy = true;\n"
        "            let task;\n"
        "            try {\n"
        "              task = target.request(prop, params);\n"
        "            } catch (e) {\n"
        "              busy = false;\n"
        "              throw e;\n"
        "            }\n"
        "            return globalThis.__scheduleTask(task).then(\n"
        "              (msg) => {\n"
        "                busy = false;\n"
        "                if (!msg) {\n"
        "                  throw new Error('No response for command: ' + prop);\n"
        "                }\n"
        "                if (msg.status === 'error') {\n"
        "                  const data = (msg.data && typeof msg.data === 'object') ? msg.data : {};\n"
        "                  const err = new Error(data.message || ('Command failed: ' + prop));\n"
        "                  err.code = msg.code;\n"
        "                  err.data = msg.data;\n"
        "                  throw err;\n"
        "                }\n"
        "                return msg.data;\n"
        "              },\n"
        "              (err) => {\n"
        "                busy = false;\n"
        "                throw err;\n"
        "              }\n"
        "            );\n"
        "          };\n"
        "        }\n"
        "        return undefined;\n"
        "      }\n"
        "    });\n"
        "  };\n"
        "})";

    JSValue factory = JS_Eval(ctx, kFactorySource, std::strlen(kFactorySource),
                              "<stdiolink/open_driver_factory>", JS_EVAL_TYPE_GLOBAL);
    if (JS_IsException(factory)) {
        return factory;
    }

    JSValue args[1] = {driverCtor};
    JSValue openDriver = JS_Call(ctx, factory, JS_UNDEFINED, 1, args);
    JS_FreeValue(ctx, factory);
    return openDriver;
}
